---
title: "Mathematical description of models in the bmstate package"
author: Juho Timonen
date: 4th Nov 2025
output: 
  rmarkdown::html_vignette:
    toc: true 
    toc_depth: 3
    number_sections: true
    
bibliography: references.bib
editor: source
vignette: >
  %\VignetteIndexEntry{Mathematical description of models in the bmstate package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(bmstate)
library(ggplot2)
theme_set(theme_bw())
```

# Multistate modeling

## States and transitions

In a multistate model, we can represent
the possible *transitions* between *states* as directed edges of a graph whose
$S$ nodes correspond to states $s \in {1, \ldots, S}$. The transitions that 
start from the same node are 
all at risk simultaneously when the system is in this state. The transitions
that are at risk simultaneously are
competing, meaning that occurrence of one transition censors the other ones.

```{r tmat, fig.width=3.5, fig.height=3}
tmat <- transmat_full(LETTERS[1:3])
tmat$plot()
```

```{r stprint}
tmat$states_df()
```

```{r tmatprint}
tmat$trans_df()
```

## Hazard model

For each transition $h = 1, \ldots, H$ and observation
unit $n = 1, \ldots, N$, the hazard rates $\lambda^{(h)}_n(t)$, $h = 1, \ldots, H$,
are modeled as
$$
\lambda^{(h)}_n(t) = b^{(h)}(t)\exp\left(\beta_{T_h}^{\top} \mathbf{x}_n \right)
$$

where

- $b^{(h)}(t)$ represents the baseline hazard for transition $h$
- $T_h$ is an integer indexing the type (`trans_type`) of transition $h$
- $\beta_{T_h}$ is the regression coefficient for transition
type $T_h$
- $\mathbf{x}_n$ includes time-independent covariates for unit $n$

We group transitions that end in the same state together to have 
the same transition type.

```{r tmat2, fig.width=3.5, fig.height=3}
tmat <- transmat_full(LETTERS[1:3])
el <- parse(text = paste0("lambda[n]^(", c(1, 3, 2, 4), ")"))
tmat$plot(edge_labs = el, edge.label.cex = 1.5)
```

## Baseline hazards

Each log baseline hazard $\log b^{(h)}(t)$ is modeled nonparametrically
so that
$$
\log \left(b^{(h)}(t)\right) = b_0^{(h)} + B^{(h)}(t)
$$
where $b_0^{(h)}$ is a constant and $B^{(h)}(t)$ is time-dependent variation
modeled using B-splines. The knot locations for the splines are same for all
transitions, and are set based on the quantiles of all transition times.

## Priors

Currently the package uses a standard normal prior for the coefficients 
$\beta$. The prior for the weights of the spline basis functions is
set hierarchically so that transitions
of same type have a shared mean. Also the average log hazard rates
$b_0^{(h)}$ have a hierarchical prior so that transitions of the same type
have a shared mean. This prior mean is estimated from the data using a standard
Cox proportional hazards model fit.


# State visit risk prediction

We often ultimately want the model to be able to predict, for a given 
subject, the probability that a particular state is visited at least once
before time $t$, given
an initial state $s_0$ at time $t_0$. We denote this probability
by $P(s \mid t, s_0, t_0)$.

## Path generation

For any subject, which does not
need to be part of the training data, we can generate a number of state paths 
starting from $s_0$ at time $t_0$. This can be done via the
`generate_paths()` function. For drawing the arrival times for 
a non-homogeneous Poisson process in path 
generation, we use the thinning algorithm [@lewis1979].

The probability $P(s \mid t, s_0, t_0)$ can then be estimated as the proportion of paths in which $s$ was visited before time $t$. This can be done via the function `p_state_visit_per_subject()`.

## Kolmogorov forward equations

### Generator matrix

If the transition matrix of the multistate model has no self-loops, it is
a continuous-time Markov process [@norris1997]. In this special case, we can
define a generator matrix $\mathbf{Q}(t) = [q_{jk}(t)]$, where $q_{kj}(t)$ is called
the transition rate from state $k$ to state $j$. The
transition rate for $k \neq j$ is $0$ if the corresponding transition is not 
possible, and
otherwise it is given by the corresponding hazard function. Additionally,
\begin{equation}
q_{kk}(t) = -\sum_{j \neq k} q_{kj}(t)
\end{equation}
for all diagonal values $k \in {1, \ldots, S}$.

### Transition probability matrix

We also define a transition probability matrix $\mathbf{P}_{t_0}(t)$, where the
element on the $i$th row and $j$th column is the probability that the process is in state $j$ at time $t$, given that it started in state $i$ at time $t_0$. The Kolmogorov forward equations  are
\begin{equation}
\frac{\text{d}}{\text{d}t} \mathbf{P}_{t_0}(t) = \mathbf{P}_{t_0}(t) \mathbf{Q}(t),
\end{equation}
and we can solve $\mathbf{P}_{t_0}(t)$ using the initial condition 
$\mathbf{P}_{t_0}(t_0) = I$. 

### State occupancy probability

The function `p_state_occupancy()` can be used to compute, for a set of
output times $t_{\mathrm{end}}$, the probability that
a subject occupies the a certain state $s$ given their state $s_0$
at the initial time. For terminal states, the state occupancy probability at
time $t$ is the state visit probability $P(s \mid t, s_0, t_0)$.

# Examples of multistate models

In this section, we illustrate some common multistate models.

```{r}
N_sub <- 1000

# Plot event time distribution
plot_time_dist <- function(t) {
  checkmate::assert_numeric(t)
  ggplot(data.frame(Time = t), aes(x = .data$Time)) +
    ggdist::stat_halfeye() +
    geom_vline(
      mapping = NULL,
      xintercept = mean(t),
      color = "gray20",
      lty = 2
    )
}
```

## Basic survival model

```{r}
tm <- transmat_survival()
s <- tm$states
```

The basic survival model can be seen as a multistate model with two states:
`r s[1]` and `r s[2]`. The death *event* corresponds to transitioning from
the state `r s[1]` to the terminal state `r s[2]`. First we create a `TransitionMatrix`. The transition matrix is a directed
graph encoded by a binary matrix.

```{r, fig.width=5}
print(tm)
tm$plot()
```

Then we create a `MultistateModel` using this graph.

```{r}
tmax <- 3 * 365.25
mod <- create_msm(tm, t_max = tmax)
print(mod)
```

Now we can simulate death events with known constant hazard rate `lambda`. For this
model, we are simulating from a homogeneous Poisson process with rate $\lambda$,
meaning that the event times should follow an exponential distribution with
mean $\frac{1}{\lambda}$.

```{r, fig.width=5}
lambda <- 1e-2
pd <- mod$simulate_data(N_sub, w0 = lambda)
pd$paths$plot_paths()
pd$paths$plot_graph()
```

We plot the distribution of event times (i.e., transition times) and the theoretical mean (red line).

```{r, fig.width=5}
times <- pd$paths$transition_times()
plot_time_dist(times) + geom_vline(xintercept = 1 / lambda, color = "firebrick")
```

Here generate paths with a lower hazard so that they can get censored
before the follow-up ends. We compute the risk of death based on paths and 
ensure that it is correct.

```{r, fig.width=5}
solve_p <- function(mod, lambda) {
  tt <- c(0, mod$system$get_tmax())
  P <- solve_trans_prob_matrix(mod$system, t_out = tt, log_w0 = log(lambda))
  P[2, 1, ]
}
solve_P_consthaz <- function(mod, h0) {
  Q_true <- mod$system$intensity_matrix(mod$system$get_tmax(), log(h0))
  Matrix::expm(Q_true * mod$system$get_tmax())
}
lambda <- 1e-3
pd <- mod$simulate_data(N_sub, w0 = lambda)
p <- solve_p(mod, lambda)
p_death1 <- p_state_visit(pd$paths)$prob
p_death2 <- p[2]
r <- c(p_death1, p_death2)
names(r) <- c("Paths", "Analytic")
print(r)
```

## Competing risks model

The transition matrix is for a competing risks model can be created like so.

```{r, fig.width=5}
tm <- transmat_comprisk()
print(tm)
tm$plot()
mod <- create_msm(tm, t_max = tmax)
```

This model has 3 possible transitions. 
Now we can simulate events with known constant hazard rates `lambda_1`, 
`lambda_2`, `lambda_3`. For this
model, we are simulating from independent homogeneous Poisson processes with 
rates $\lambda_i$, meaning that the transition probabilities should be
$$
P(i) = \frac{\lambda_i}{\sum_{j=1}^ 3 \lambda_j}.
$$

```{r, fig.width=5}
lambda <- 1e-2
w0 <- c(lambda, 2 * lambda, 3 * lambda)
print(w0 / sum(w0))
```

```{r, fig.width=5}
pd <- mod$simulate_data(N_sub, w0 = w0)
pd$paths$plot_paths()
pd$paths$plot_graph()
```

The distribution of event times should be exponentially distributed with
mean $\frac{1}{\lambda_0}$ where
$$
\lambda_0 = \sum_{j=1}^ 3 \lambda_j
$$
is the combined hazard rate. We plot the empirical distribution and the theoretical mean (red line).
```{r, fig.width=5}
times <- pd$paths$as_transitions(truncate = TRUE)$time
plot_time_dist(times) + geom_vline(xintercept = 1 / sum(w0), color = "firebrick")
```

Here we again generate paths with a lower hazard so that they can get censored
before the follow-up ends. We compute the probability of different terminal
states at the end of follow up based on paths and 
ensure that they are correct.

```{r, fig.width=5}
pd <- mod$simulate_data(N_sub, w0 = 0.01 * w0)
p <- solve_p(mod, 0.01 * w0)
p_death1 <- p_state_visit(pd$paths)$prob
p_death2 <- p[2:4]
r <- rbind(p_death1, p_death2)
rownames(r) <- c("Paths", "Analytic")
print(r)
```


## Illness-death model

The illness-death model is another common multistate model.

```{r, fig.width=5}
tm <- transmat_illnessdeath()
print(tm)
tm$plot()
mod <- create_msm(tm)
w0 <- 1e-2
pd <- mod$simulate_data(N_sub, w0 = w0)
pd$paths$plot_paths()
pd$paths$plot_graph()
```


Here we again generate paths with a lower hazard so that they can get censored
before the follow-up ends. We compute the probability of death before the end 
of follow up based on paths and 
ensure that it is correct.

```{r, fig.width=5}
h0_true <- 0.5 * 1e-3
h0_true_vec <- rep(h0_true, 3)
h0_true_vec[2] <- 0.1 * h0_true
h0_true_vec[3] <- 5 * h0_true
pd <- mod$simulate_data(N_sub, w0 = h0_true_vec)
p <- solve_p(mod, h0_true_vec)
P_true <- solve_P_consthaz(mod, h0_true_vec)
p_death1 <- p_state_visit(pd$paths)$prob[2]
p_death2 <- p[3]
p_death3 <- P_true[1, 3]
r <- c(p_death1, p_death2, p_death3)

names(r) <- c("Paths", "Analytic", "Analytic2")
print(r)
```


## Diamond model

This model is a more complex multistate model.

```{r, fig.width=5}
tm <- transmat_diamond()
print(tm)
tm$plot()
mod <- create_msm(tm)
w0 <- 1e-2
pd <- mod$simulate_data(N_sub, w0 = w0)
pd$paths$plot_paths()
pd$paths$plot_graph()
```

Here we again generate paths with a lower hazard so that they can get censored
before the follow-up ends. We compute the probability of death before the end 
of follow up based on paths and
ensure that it is correct.

```{r, fig.width=5}
h0_true <- 0.5 * 1e-3
h0_true_vec <- rep(h0_true, 7)
h0_true_vec[3] <- 0.1 * h0_true
h0_true_vec[5] <- 5 * h0_true
h0_true_vec[7] <- 20 * h0_true
# h0_true_vec <- rep(1e-8, 7)
# h0_true_vec[3] <- 1e-3

P_true <- solve_P_consthaz(mod, h0_true_vec)
p_death3 <- P_true[1, 4]
w0 <- h0_true_vec
pd <- mod$simulate_data(N_sub, w0 = w0)
p <- solve_p(mod, w0)
p_death1 <- p_state_visit(pd$paths)$prob[3]
p_death2 <- p[4]
r <- c(p_death1, p_death2, p_death3)
names(r) <- c("Paths", "Analytic", "Analytic2")
print(r)
```

## General multistate models

General multistate models can have multiple terminal states and various
transitions.

```{r, fig.width=5}
tm <- transmat_full(state_names = LETTERS[1:5], sources = 1, terminal = c(4, 5))
print(tm)
tm$plot()
mod <- create_msm(tm)
pd <- mod$simulate_data(N_sub, w0 = 1e-3)
pd$paths$plot_paths()
pd$paths$plot_graph()
```

Some of the paths may not reach a terminal state
before `t_max`, meaning they get censored (no event)

```{r, fig.width=5}
pd$paths$prop_matrix()
```

# References




