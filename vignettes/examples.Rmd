---
title: "Common multistate models"
author: Juho Timonen
date: 1st Oct 2025
output: 
  rmarkdown::html_vignette:
    toc: true 
    toc_depth: 3
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Common multistate models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

In this vignette, we illustrate some common multistate models.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(bmstate)
library(ggplot2)
theme_set(theme_bw())
N_sub <- 1000

# Plot event time distribution
plot_time_dist <- function(t) {
  checkmate::assert_numeric(t)
  ggplot(data.frame(Time = t), aes(x = .data$Time)) +
    ggdist::stat_halfeye() +
    geom_vline(
      mapping = NULL,
      xintercept = mean(t),
      color = "gray20",
      lty = 2
    )
}
```

# Basic survival model

```{r}
tm <- transmat_survival()
s <- tm$states
```

The basic survival model can be seen as a multistate model with two states:
`r s[1]` and `r s[2]`. The death *event* corresponds to transitioning from
the state `r s[1]` to the terminal state `r s[2]`. First we create a `TransitionMatrix`. The transition matrix is a directed
graph encoded by a binary matrix.

```{r, fig.width=5}
print(tm)
tm$plot()
```

Then we create a `MultistateModel` using this graph.

```{r}
tmax <- 3 * 365.25
mod <- create_msm(tm, tmax = tmax)
print(mod)
```

Now we can simulate death events with known constant hazard rate `lambda`. For this
model, we are simulating from a homogeneous Poisson process with rate $\lambda$,
meaning that the event times should follow an exponential distribution with
mean $\frac{1}{\lambda}$.

```{r, fig.width=5}
lambda <- 1e-2
pd <- mod$simulate_data(N_sub, w0 = lambda)
pd$paths$plot_paths()
pd$paths$plot_graph()
```

We plot the distribution of event times (i.e., transition times) and the theoretical mean (red line).

```{r, fig.width=5}
times <- pd$paths$as_transitions(truncate = TRUE)$time
plot_time_dist(times) + geom_vline(xintercept = 1 / lambda, color = "firebrick")
```

Here generate paths with a lower hazard so that they can get censored
before the follow-up ends. We compute the risk of death based on paths and 
ensure that it is correct.

```{r, fig.width=5}
solve_p <- function(mod, lambda) {
  tt <- c(0, mod$system$get_tmax())
  P <- solve_trans_prob_matrix(mod$system, t_out = tt, log_w0 = log(lambda))
  P[2, 1, ]
}
solve_P_consthaz <- function(mod, h0) {
  Q_true <- mod$system$intensity_matrix(mod$system$get_tmax(), log(h0))
  Matrix::expm(Q_true * mod$system$get_tmax())
}
lambda <- 1e-3
pd <- mod$simulate_data(N_sub, w0 = lambda)
p <- solve_p(mod, lambda)
p_death1 <- p_state_visit(pd$paths)$prob
p_death2 <- p[2]
r <- c(p_death1, p_death2)
names(r) <- c("Paths", "Analytic")
print(r)
```

# Competing risks model

The transition matrix is for a competing risks model can be created like so.

```{r, fig.width=5}
tm <- transmat_comprisk()
print(tm)
tm$plot()
mod <- create_msm(tm, tmax = tmax)
```

This model has 3 possible transitions. 
Now we can simulate events with known constant hazard rates `lambda_1`, 
`lambda_2`, `lambda_3`. For this
model, we are simulating from independent homogeneous Poisson processes with 
rates $\lambda_i$, meaning that the transition probabilities should be
$$
P(i) = \frac{\lambda_i}{\sum_{j=1}^ 3 \lambda_j}.
$$

```{r, fig.width=5}
lambda <- 1e-2
w0 <- c(lambda, 2 * lambda, 3 * lambda)
print(w0 / sum(w0))
```

```{r, fig.width=5}
pd <- mod$simulate_data(N_sub, w0 = w0)
pd$paths$plot_paths()
pd$paths$plot_graph()
```

The distribution of event times should be exponentially distributed with
mean $\frac{1}{\lambda_0}$ where
$$
\lambda_0 = \sum_{j=1}^ 3 \lambda_j
$$
is the combined hazard rate. We plot the empirical distribution and the theoretical mean (red line).
```{r, fig.width=5}
times <- pd$paths$as_transitions(truncate = TRUE)$time
plot_time_dist(times) + geom_vline(xintercept = 1 / sum(w0), color = "firebrick")
```

Here we again generate paths with a lower hazard so that they can get censored
before the follow-up ends. We compute the probability of different terminal
states at the end of follow up based on paths and 
ensure that they are correct.

```{r, fig.width=5}
pd <- mod$simulate_data(N_sub, w0 = 0.01 * w0)
p <- solve_p(mod, 0.01 * w0)
p_death1 <- p_state_visit(pd$paths)$prob
p_death2 <- p[2:4]
r <- rbind(p_death1, p_death2)
rownames(r) <- c("Paths", "Analytic")
print(r)
```


# Illness-death model

The illness-death model is another common multistate model.

```{r, fig.width=5}
tm <- transmat_illnessdeath()
print(tm)
tm$plot()
mod <- create_msm(tm)
w0 <- 1e-2
pd <- mod$simulate_data(N_sub, w0 = w0)
pd$paths$plot_paths()
pd$paths$plot_graph()
```


Here we again generate paths with a lower hazard so that they can get censored
before the follow-up ends. We compute the probability of death before the end 
of follow up based on paths and 
ensure that it is correct.

```{r, fig.width=5}
h0_true <- 0.5 * 1e-3
h0_true_vec <- rep(h0_true, 3)
h0_true_vec[2] <- 0.1 * h0_true
h0_true_vec[3] <- 5 * h0_true
pd <- mod$simulate_data(N_sub, w0 = h0_true_vec)
p <- solve_p(mod, h0_true_vec)
P_true <- solve_P_consthaz(mod, h0_true_vec)
p_death1 <- p_state_visit(pd$paths)$prob[2]
p_death2 <- p[3]
p_death3 <- P_true[1, 3]
r <- c(p_death1, p_death2, p_death3)

names(r) <- c("Paths", "Analytic", "Analytic2")
print(r)
```


# Diamond model

This model is a more complex multistate model.

```{r, fig.width=5}
tm <- transmat_diamond()
print(tm)
tm$plot()
mod <- create_msm(tm)
w0 <- 1e-2
pd <- mod$simulate_data(N_sub, w0 = w0)
pd$paths$plot_paths()
pd$paths$plot_graph()
```

Here we again generate paths with a lower hazard so that they can get censored
before the follow-up ends. We compute the probability of death before the end 
of follow up based on paths and
ensure that it is correct.

```{r, fig.width=5}
h0_true <- 0.5 * 1e-3
h0_true_vec <- rep(h0_true, 7)
h0_true_vec[3] <- 0.1 * h0_true
h0_true_vec[5] <- 5 * h0_true
h0_true_vec[7] <- 20 * h0_true
# h0_true_vec <- rep(1e-8, 7)
# h0_true_vec[3] <- 1e-3

P_true <- solve_P_consthaz(mod, h0_true_vec)
p_death3 <- P_true[1, 4]
w0 <- h0_true_vec
pd <- mod$simulate_data(N_sub, w0 = w0)
p <- solve_p(mod, w0)
p_death1 <- p_state_visit(pd$paths)$prob[3]
p_death2 <- p[4]
r <- c(p_death1, p_death2, p_death3)
names(r) <- c("Paths", "Analytic", "Analytic2")
print(r)
```

# General multistate models

General multistate models can have multiple terminal states and various
transitions.

```{r, fig.width=5}
tm <- transmat_full(state_names = LETTERS[1:5], sources = 1, terminal = c(4, 5))
print(tm)
tm$plot()
mod <- create_msm(tm)
pd <- mod$simulate_data(N_sub, w0 = 1e-3)
pd$paths$plot_paths()
pd$paths$plot_graph()
```

Some of the paths may not reach a terminal state
before `t_max`, meaning they get censored (no event)

```{r, fig.width=5}
pd$paths$prop_matrix()
```

